[{"title":"3231note","date":"2023-04-25T14:32:58.000Z","url":"/2023/04/26/3231note/","tags":[["COMP3231","/tags/COMP3231/"]],"categories":[["notes","/categories/notes/"]],"content":"UNSW COMP3231 23T1 notes Lec 02 Processes and ThreadsProcesses:â€¢ Also called a task or job â€¢ Memory image of an individual program â€¢ â€œOwnerâ€ of resources allocated for program execution â€¢ Encompasses one or more threads Threads:â€¢ Unit of execution æ‰§è¡Œå‘½ä»¤çš„å•ä½ â€¢ Can be traced â€¢ list the sequence of instructions that execute â€¢ Belongs to a process â€¢ Executes within it. One Process may contain one or more threads. Process TerminationConditions which terminate processes 1. Normal exit (voluntary) 2. Error exit (voluntary) 3. Fatal error (involuntary) 4. Killed by another process (involuntary) Process and Thread StatesRunning Blocked Ready Running â†’ Readyâ€¢ Voluntary Yield() â€¢ End of timeslice Running â†’ Blockedâ€¢ Waiting for input â€¢ File, network, â€¢ Waiting for a timer (alarm signal) â€¢ Waiting for a resource to become available SchedularSometime called as dispatcher, it will choose a ready process to run. BUT: It is inefficient to search through all processes e.g: Ready Queue &amp; Blocked Queue Thread Model Per process items Per thread items Address spaceGlobal variablesOpen filesChild processesPending alarmsSignals and signal handlersAccounting information Program counterRegistersStack (Each thread has its own stack)State Local variables are per thread (allocated on the stack) Global variables are shared between all threads (Allocated in the data section) Concurrency control is an issue. Dynamically allocated memory can be global or local -&gt; Program defined Thread Usage Model æ¨¡å‹ Characteristics ç‰¹æ€§ Threads Parallelism. Blocking system calls Single-threaded Process No parallelism, blocking system calls Finite-state Machine Parallelism, nonblocking system calls, interrupts Summary in Threads Simpler to program than a state machine Less resources associated with threads than multiple complete processes Cheaper to create and destroy Share resources (especially memory) between them Performance: Threads waiting for IO can be overlapped with computing threads If all threads are compute bound(è¢«è¿ç®—é€Ÿåº¦é™åˆ¶), then there is no performance improvement (on uniprocessor) Threads can take advantage of the parallelism available on machines with more than one CPU (multiprocessor) Lec 03 Concurrency and SynchronisationConcurrency Example:Trying to modify a global variable in two threads The reason for why there is in-kernel concurrency for single-threaded processes: Multi-tasking Interrupt handling Device drivers System calls Resource sharing Critical Region and how to identifyA critical region is a region of code where shared resources are accessed. We can control access to the shared resource by controlling access to the code that accesses the resource. Uncoordinated entry to the critical region results in a race condition (Concurrency Occurs) HOW TO IDENTIFY: Critical regions are the regions of code that access a shared resource, and correctness relies on the shared resource not being concurrently modified by another thread&#x2F;process&#x2F;entity.\\ HOW TO PREVENT: Critical Regions SolutionsConditions required of any solution to the critical region problem: Mutual exclusion: No two processes&#x2F;threads in the critical region at the same time No assumptions made about speeds or numbers of CPUs No process running outside its critical region may block another process No process waited forever to enter its critical region (Bounded) Mutual exclusion by taking turnsWorks for solving concurrency issues: strict alternation -&gt; each process takes turns Cons (ç¼ºç‚¹) Busy waiting Process must wait its turn even while the other process is doing something else In a multiple processes condition, must wait for everyone to have a turn Does not guarantee progress if a process no longer needs a turn Poor solution when processes require the critical section at different rates Mutual Exclusion by disabling interruptsHow it works: Before entering a critical region, disable interrupts. After leaving the critical region, enable interrupts. Cons: Only available in the kernel Delays everybody else, even with no contention Slows the interrupt response time Does not work on a multiprocessor Hardware Support for mutual exclusionTest and Set instruction â€¢Can be used to implement lock variables correctly â€¢Load the value of the lock â€¢If lock &#x3D;&#x3D; 0 â€¢Set the lock to 1 â€¢Return the result 0 -&gt; we acquire the lock â€¢if lock &#x3D;&#x3D; 1 â€¢ return 1 -&gt; another thread&#x2F;process has the lock â€¢Hardware guarantees that the instruction executes atomically -&gt; not be interrupt Pros: Simple (easy to verify work or not) Available at user level Work with any number of processors To implement any number of lock variables Cons: Busy waits (also named as a spin lock) Consumes CPU Starvation is possible when a process leaves its critical section and more than one process is waiting. Tackling the busy-wait problem:Sleep&#x2F;Wakeup When the process is waiting for an event, it calls sleep to block, instead of busy waiting. The event happens, the event generator (another process) calls wakeup to unblock the sleeping process. Waking a ready&#x2F;running process has no effect. Producer-Consumer Problem(bounded buffer problem)Description: producer produces data items and store items in a buffer. Consumer takes the items out of the buffer and consumes them. Issues:Producer Should sleep when the buffer is full. And wakeup when there is empty space in the buffer. The consumer can call wakeup when it consumes the first entry of the full buffer. Consumer Should sleep when the buffer is empty. And wakeup when there are items available. Producer can call wakeup when it adds the first item to the buffer. SemaphoresTwo primitives that are more powerful than simple sleep and wakeup alone. â€¢ P(): proberen, from Dutch to test. â€¢ V(): verhogen, from Dutch to increment. â€¢ Also called wait &amp; signal, down &amp; up. How it works: If a resource is not available, the corresponding semaphore blocks any process waiting for the resource. Blocked processes are put into a process queue maintained by the semaphore (avoids busy waiting!) When a process releases a resource, it signals this by means of the semaphore. Signaling resumes a blocked process if there is any. Wait (P) and signal (V) operations cannot be interrupted. Complex coordination can be implemented by multiple semaphores. The initial count determines how many waits can progress before blocking and requiring a signal. Producer Consumer problem with semaphores: Summarising SemaphoresSemaphores can be used to solve a variety of concurrency problems. However, programming with then can be error-prone: E.g. must signal for every wait To many or too few signals or waits, or signals and waits in the wrong order, can have bad results. MonitorA higher level synchronisation primitive. Programming language construct IDEA: A set of procedures&#x2F;variables&#x2F;data types are grouped in a special module:monitor. Variables and data types can only be accessed from within the monitor. Only one process&#x2F;thread can be in the monitor at any one time. Mutual exclusion is implemented by the complier. When a thread calls a monitor procedure that has a thread already inside, it will be in the entry queue and will sleep until the current thread exits the monitor. Condition VariableTo allow a process to wait within the monitor, we need to declare a condition variable. Condition variable can only be used with the operations wait and signal. x.wait() Means that the process invoking this operation is suspended until another process invokes. Another thread can enter the monitor while original is suspended. x.signal() this operation resumes only one suspended process. If no process is suspended, then this operation has no effect. How to achieve producer-consumer problem with monitors is in P50 lec03. Synchronisation Primitives in OS&#x2F;161Locks Semaphores Wait (P) &#x2F; signal (V) Condition Variables Note: All three variants must hold the lock passed in. Condition Variables and Bounded Buffers cv_wait() will release the lock before block the process Producer-consumer solution with condition variable Dining Philosopherså“²å­¦å®¶å°±é¤é—®é¢˜æ˜¯ä¸€ä¸ªç»å…¸çš„è®¡ç®—æœºç§‘å­¦åŒæ­¥é—®é¢˜ï¼Œç”±Edsger Dijkstraåœ¨1965å¹´æå‡ºã€‚é—®é¢˜æè¿°äº†äº”ä½å“²å­¦å®¶å›´ååœ¨åœ†æ¡Œæ—çš„æƒ…æ™¯ï¼Œä»–ä»¬åœ¨æ€è€ƒé—®é¢˜å’Œåƒé¥­ä¹‹é—´äº¤æ›¿ã€‚åœ†æ¡Œä¸­é—´æœ‰ä¸€ç¢—æ„é¢ï¼Œæ¯ä¸¤ä½å“²å­¦å®¶ä¹‹é—´æœ‰ä¸€æ ¹ç­·å­ã€‚æ¯ä½å“²å­¦å®¶éœ€è¦ä¸¤æ ¹ç­·å­æ‰èƒ½åƒé¥­ã€‚å“²å­¦å®¶ä»¬ä¸èƒ½äº¤è°ˆï¼Œåªèƒ½æ€è€ƒæˆ–åƒé¥­ã€‚ é—®é¢˜åœ¨äºè®¾è®¡ä¸€ä¸ªåè®®ï¼Œä½¿å¾—æ¯ä½å“²å­¦å®¶éƒ½èƒ½å¤Ÿåœ¨éœ€è¦æ—¶ä½¿ç”¨ä¸¤æ ¹ç­·å­åƒé¥­ï¼Œè€Œä¸ä¼šå‡ºç°æ­»é”ï¼ˆå³æ‰€æœ‰å“²å­¦å®¶éƒ½åœ¨ç­‰å¾…ç­·å­ï¼Œæ— æ³•ç»§ç»­åƒé¥­ï¼‰æˆ–è€…é¥¥é¥¿ï¼ˆå³æŸä½å“²å­¦å®¶é•¿æ—¶é—´æ— æ³•è·å¾—ç­·å­ï¼‰çš„æƒ…å†µã€‚ ä»¥ä¸‹æ˜¯ä¸€ä¸ªå¯èƒ½çš„è§£å†³æ–¹æ¡ˆï¼š æˆ‘ä»¬å¯ä»¥ä¸ºæ¯æ ¹ç­·å­åˆ†é…ä¸€ä¸ªç¼–å·ï¼ˆä¾‹å¦‚ï¼Œ1åˆ°5ï¼‰ï¼Œå¹¶ä¸ºæ¯ä½å“²å­¦å®¶åˆ†é…ä¸€ä¸ªç¼–å·ã€‚æ¯ä½å“²å­¦å®¶åœ¨éœ€è¦åƒé¥­æ—¶ï¼Œå…ˆå°è¯•æ‹¿èµ·ç¼–å·è¾ƒä½çš„ç­·å­ï¼Œç„¶åå°è¯•æ‹¿èµ·ç¼–å·è¾ƒé«˜çš„ç­·å­ã€‚å½“å“²å­¦å®¶åŒæ—¶æ‹¥æœ‰ä¸¤æ ¹ç­·å­æ—¶ï¼Œä»–ä»¬å¯ä»¥å¼€å§‹åƒé¥­ã€‚åƒå®Œé¥­åï¼Œä»–ä»¬å°†ç­·å­æ”¾å›åŸä½ï¼Œç„¶åç»§ç»­æ€è€ƒã€‚ è¿™ç§æ–¹æ³•å¯ä»¥é¿å…æ­»é”ï¼Œå› ä¸ºè‡³å°‘æœ‰ä¸€ä½å“²å­¦å®¶ï¼ˆå…·æœ‰æœ€ä½ç¼–å·ç­·å­çš„å“²å­¦å®¶ï¼‰å¯ä»¥æ‹¿èµ·ä¸¤æ ¹ç­·å­å¹¶å¼€å§‹åƒé¥­ã€‚å…¶ä»–å“²å­¦å®¶åˆ™éœ€è¦ç­‰å¾…ç­·å­è¢«æ”¾å›ã€‚è™½ç„¶è¿™ç§æ–¹æ³•å¯èƒ½å¯¼è‡´æŸäº›å“²å­¦å®¶ç­‰å¾…æ—¶é—´è¾ƒé•¿ï¼Œä½†å¯ä»¥ç¡®ä¿æ‰€æœ‰å“²å­¦å®¶éƒ½æœ‰æœºä¼šåƒé¥­ï¼Œé¿å…é¥¥é¥¿ç°è±¡ã€‚ Reader and Writer Problemè¯»è€…-å†™è€…é—®é¢˜æ˜¯ä¸€ä¸ªç»å…¸çš„è®¡ç®—æœºç§‘å­¦å¹¶å‘æ§åˆ¶é—®é¢˜ï¼Œç”¨äºæè¿°å¤šä¸ªè¿›ç¨‹åœ¨è®¿é—®å…±äº«èµ„æºæ—¶éœ€è¦è¿›è¡ŒåŒæ­¥çš„åœºæ™¯ã€‚åœ¨è¿™ä¸ªé—®é¢˜ä¸­ï¼Œæœ‰ä¸€äº›è¯»è€…è¿›ç¨‹å’Œå†™è€…è¿›ç¨‹ã€‚è¯»è€…è¿›ç¨‹åªè¯»å–å…±äº«èµ„æºï¼Œè€Œå†™è€…è¿›ç¨‹å¯ä»¥ä¿®æ”¹å…±äº«èµ„æºã€‚é—®é¢˜çš„æŒ‘æˆ˜åœ¨äºè®¾è®¡ä¸€ä¸ªåŒæ­¥åè®®ï¼Œä»¥å…è®¸å¤šä¸ªè¯»è€…è¿›ç¨‹åŒæ—¶è®¿é—®å…±äº«èµ„æºï¼Œä½†åœ¨å†™è€…è¿›ç¨‹è®¿é—®èµ„æºæ—¶ï¼Œç¡®ä¿å…¶ä»–è¿›ç¨‹ï¼ˆè¯»è€…å’Œå†™è€…ï¼‰æ— æ³•è®¿é—®èµ„æºã€‚ ä»¥ä¸‹æ˜¯ä¸€ä¸ªå¯èƒ½çš„è§£å†³æ–¹æ¡ˆï¼š æˆ‘ä»¬å¯ä»¥ä½¿ç”¨äº’æ–¥é‡ï¼ˆmutexï¼‰å’Œä¿¡å·é‡ï¼ˆsemaphoreï¼‰æ¥å®ç°è¿™ä¸ªåè®®ã€‚åœ¨è¿™ä¸ªè§£å†³æ–¹æ¡ˆä¸­ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªäº’æ–¥é‡æ¥ä¿æŠ¤å¯¹å…±äº«èµ„æºçš„è®¿é—®è®¡æ•°å™¨ï¼Œä»¥åŠä¸€ä¸ªä¿¡å·é‡æ¥æ§åˆ¶å¯¹å…±äº«èµ„æºçš„è®¿é—®ã€‚ è¯»è€…è¿›ç¨‹ï¼š è¯·æ±‚äº’æ–¥é‡ä»¥ä¿®æ”¹è®¿é—®è®¡æ•°å™¨ã€‚ å°†è®¿é—®è®¡æ•°å™¨åŠ 1ã€‚å¦‚æœè¿™æ˜¯ç¬¬ä¸€ä¸ªè¯»è€…è¿›ç¨‹ï¼Œè¯·æ±‚ä¿¡å·é‡ä»¥é˜»æ­¢å†™è€…è¿›ç¨‹è®¿é—®å…±äº«èµ„æºã€‚ é‡Šæ”¾äº’æ–¥é‡ã€‚ è®¿é—®å…±äº«èµ„æºã€‚ è¯·æ±‚äº’æ–¥é‡ä»¥ä¿®æ”¹è®¿é—®è®¡æ•°å™¨ã€‚ å°†è®¿é—®è®¡æ•°å™¨å‡1ã€‚å¦‚æœè¿™æ˜¯æœ€åä¸€ä¸ªè¯»è€…è¿›ç¨‹ï¼Œé‡Šæ”¾ä¿¡å·é‡ä»¥å…è®¸å†™è€…è¿›ç¨‹è®¿é—®å…±äº«èµ„æºã€‚ é‡Šæ”¾äº’æ–¥é‡ã€‚ å†™è€…è¿›ç¨‹ï¼š è¯·æ±‚ä¿¡å·é‡ä»¥é˜»æ­¢å…¶ä»–è¿›ç¨‹è®¿é—®å…±äº«èµ„æºã€‚ è®¿é—®å…±äº«èµ„æºã€‚ é‡Šæ”¾ä¿¡å·é‡ä»¥å…è®¸å…¶ä»–è¿›ç¨‹è®¿é—®å…±äº«èµ„æºã€‚ è¿™ä¸ªè§£å†³æ–¹æ¡ˆå…è®¸å¤šä¸ªè¯»è€…è¿›ç¨‹åŒæ—¶è®¿é—®å…±äº«èµ„æºï¼Œä½†å½“æœ‰å†™è€…è¿›ç¨‹éœ€è¦è®¿é—®èµ„æºæ—¶ï¼Œå®ƒä»¬å°†ç­‰å¾…æ‰€æœ‰å½“å‰çš„è¯»è€…è¿›ç¨‹å®Œæˆã€‚åŒæ ·ï¼Œåœ¨å†™è€…è¿›ç¨‹è®¿é—®å…±äº«èµ„æºæ—¶ï¼Œå…¶ä»–è¯»è€…å’Œå†™è€…è¿›ç¨‹å°†è¢«é˜»æ­¢ã€‚è¿™ç§æ–¹æ³•å¯ä»¥ç¡®ä¿åœ¨å†™è€…è¿›ç¨‹è®¿é—®èµ„æºæ—¶ï¼Œæ²¡æœ‰å…¶ä»–è¿›ç¨‹å¯ä»¥è®¿é—®å…±äº«èµ„æºã€‚ Lec04 DeadLockDeadLock &amp; ResourcesDeadlocks occurs when Processes are granted exclusive access to devices&#x2F;locks&#x2F;tables.. We refer to these entities generally as resources. Deadlock: definition A set of processes is deadlocked if each process in the set is waiting for an event that only another process in the set can cause. In the deadlock situation, no process can Run Release resources Be awakened Four conditions for deadlock Mutual exclusion condition Each resource assigned to 1 process or is available Hold and wait condition Process holding resources can request additional No preemption condition Previously granted resources cannot be forcibly taken away Circular wait condition Must be a circular chain of 2 or more processes Each is waiting for resource held by next member of the chain Deadlock avoidance Just ignore the problem altogether Prevention é¢„é˜² Negating on of the four necessary conditions Detection and recovery Dynamic avoidance Careful resource allocation Method 1: Ostrich AlgorithmPretend there is no problem Reasonable if Deadlocks occur very rarely Cost of prevention is high UNIX and Windows takes this approach for some of the more complex resource relationships they manage Itâ€™s a trade off between Convenience (engineering approach) Correctness (mathematical approach) Method 2: Deadlock preventionResource allocation rules prevent deadlock by prevent one of the four conditions required for deadlock from occurring: Mutual exclusion Hold and wait No preemption Circular Wait Attacking the Mutual Exclusion Condition (Not feasible)Not feasible in general Some devices&#x2F;resources are intrinsically(æœ¬è´¨ä¸Š) not sharable. Attacking the hold and wait condition (request resources initially)Require processes to request resources before starting A process never has to wait for what it needs Issues: May not know required resources at start of run Which means not always possible Also ties up resources other processes could be using Variations: Process must give up all resources if it would block holding a resource Then request all immediately need Prone(å€¾å‘äº) to livelock Attacking the No Preemption condition(æ— ä¼˜å…ˆæƒæ¡ä»¶)(take resources away)Not a viable option Attacking the circular wait condition (Order resources)Numerically ordered resources (Resources ordering is a common technique) Method 3: Detection and recoveryNeed a method to determine if a system is deadlocked. Assuming deadlocked is detected, we need a method of recovery to restore progress to the system. Strategy:Note the resource ownership and requests A cycle can be found within the graph, which denotes a deadlock Detection with Multiple Resources of Each Type Sum of current resource allocation + resources available &#x3D; resources that exist Algorithm Look for an unmarked process Pi, for which the i-th row of R is less than or equal to A. If found, add the i-th row of C to A, and mark Pi, then go back to step 1. If no such process exists, terminate. The remaining processes are deadlocked. Recovery from DeadlockRecovery through preemption â€¢ take a resource from some other process â€¢ depends on nature of the resource Recovery through rollback â€¢ checkpoint a process periodically â€¢ use this saved state â€¢ restart the process if it is found deadlocked â€¢ No guarantee is wonâ€™t deadlock again Recovery through killing processes â€¢ crudest but simplest way to break a deadlock â€¢ kill one of the processes in the deadlock cycle â€¢ the other processes get its resources â€¢ choose process that can be rerun from the beginning Method 4: Deadlock AvoidanceOnly enough information is available in advance, we can avoid a deadlock. Maximum number of each resource required Safe and Unsafe statesA state is safe if â€¢ The system is not deadlocked â€¢ There exists a scheduling order that results in every process running to completion, even if they all request their maximum resources immediately Unsafe states are not necessarily deadlocked â€¢ With a lucky sequence, all processes may complete â€¢ However, we cannot guarantee that they will complete (not deadlock) â€¢ Safe states guarantee we will eventually complete all processes â€¢Deadlock avoidance algorithm â€¢ Only grant requests that result in safe states LiveLockLivelocked processes are not blocked, change state regularly, but never make progress Bankers AlgorithmModelled on a Banker with Customers â€¢ The banker has a limited amount of money to loan customers â€¢ Limited number of resources â€¢ Each customer can borrow money up to the customerâ€™s credit limit â€¢ Maximum number of resources required Basic Idea â€¢ Keep the bank in a safe state â€¢ So all customers are happy even if they all request to borrow up to their credit limit at the same time. â€¢ Customers wishing to borrow such that the bank would enter an unsafe state must wait until somebody else repays their loan such that the the transaction becomes safe StarvationA process never receives the resource it is waiting for, despite the resource (repeatedly) becoming free, the resource is always allocated to another waiting process One Solution: First come, first server Lec05 Processes and Threads ImplementationMIPS RegistersUser-mode accessible registers â€¢ 32 general purpose registers â€¢ r0 hardwired to zero â€¢ r31 the link register for jump-and-link (JAL) instruction HI&#x2F;LO â€¢ 2 * 32-bits for multiply and divide PC â€¢ Not directly visible â€¢ Modified implicitly by jump and branch instructions Branching and JumpingBranching and jumping have a branch delay slot â€¢ The instruction following a branch or jump is always executed prior to destination of jump ProcessMemory allocationMinimally consist of three segments â€¢ Text â€¢ contains the code (instructions) â€¢ Data â€¢ Global variables â€¢ Stack â€¢ Activation records of procedure&#x2F;function&#x2F;method â€¢ Local variables Note: â€¢ data can dynamically grow up â€¢ E.g., malloc()-ing â€¢ The stack can dynamically grow down â€¢ E.g., increasing function call depth or recursion P23 lec05 Mode distinguishUser-mode â€¢ Processes (programs) scheduled by the kernel â€¢ Isolated from each other â€¢ No concurrency issues between each other System-calls transition into and return from the kernel Kernel-mode â€¢ Nearly all activities still associated with a process â€¢ Kernel memory shared between all processes â€¢ Concurrency issues exist between processes concurrently executing in a system call User-level Threads Implementation at user-level â€¢ User-level Thread Control Block (TCB), ready queue, blocked queue, and dispatcher â€¢ Kernel has no knowledge of the threads (it only sees a single process) â€¢ If a thread blocks waiting for a resource held by another thread inside the same process, its state is saved and the dispatcher switches to another ready thread â€¢ Thread management (create, exit, yield, wait) are implemented in a runtime support library Prosâ€¢ Thread management and switching at user level is much faster than doing it in kernel level â€¢ No need to trap (take syscall exception) into kernel and back to switch â€¢ Dispatcher algorithm can be tuned to the application â€¢ E.g. use priorities â€¢ Can be implemented on any OS (thread or non-thread aware) â€¢ Can easily support massive numbers of threads on a per-application basis â€¢ Use normal application virtual memory â€¢ Kernel memory more constrained. Difficult to efficiently support wildly differing numbers of threads for different applications Consâ€¢ Threads have to yield() manually (no timer interrupt delivery to user level) â€¢ Co-operative multithreading â€¢ A single poorly design&#x2F;implemented thread can monopolise the available CPU time â€¢ There are work-arounds (e.g. a timer signal per second to enable pre-emptive multithreading), they are course grain and a kludge. â€¢ Does not take advantage of multiple CPUs (in reality, we still have a single threaded process as far as the kernel is concerned) â€¢ If a thread makes a blocking system call (or takes a page fault), the process (and all the internal threads) blocks â€¢ Canâ€™t overlap I&#x2F;O with computation Kernel-provided ThreadsP38 lec05 Threads are implemented by the kernel â€¢ TCBs (thread control block) are stored in the kernel â€¢ A subset of information in a traditional PCB (process control block) â€¢ The subset related to execution context â€¢ TCBs have a PCB associated with them â€¢ Resources associated with the group of threads (the process) â€¢ Thread management calls are implemented as system calls â€¢ E.g. create, wait, exit Consâ€¢ Thread creation and destruction, and blocking and unblocking threads requires kernel entry and exit. â€¢ More expensive than user-level equivalent Prosâ€¢ Preemptive multithreading â€¢ Parallelism â€¢ Can overlap blocking I&#x2F;O with computation â€¢ Can take advantage of a multiprocessor Context SwitchContext Switch is what the lowest level of OS does when an interrupt occurs. A context switch can refer to â€¢ A switch between threads â€¢ Involving saving and restoring of state associated with a thread â€¢ A switch between processes â€¢ Involving the above, plus extra state associated with a process. â€¢ E.g. memory maps Context Switch OccurrenceA switch between process&#x2F;threads can happen any time the OS is invoked â€¢ On a system call â€¢ Mandatory if system call blocks or on exit(); â€¢ On an exception â€¢ Mandatory if offender is killed â€¢ On an interrupt â€¢ Triggering a dispatch is the main purpose of the timer interrupt A thread switch can happen between any two instructions Note instructions do not equal program statements Context Switch Addition Context switch must be transparent for processes&#x2F;threads â€¢ When dispatched again, process&#x2F;thread should not notice that something else was running in the meantime (except for elapsed time) OS must save all state that affects the thread â€¢ This state is called the process&#x2F;thread context â€¢ Switching between process&#x2F;threads consequently results in a context switch."},{"title":"test for categories","date":"2023-03-21T08:13:40.000Z","url":"/2023/03/21/test-for-cat/","tags":[["test","/tags/test/"]],"categories":[["Demo","/categories/Demo/"]],"content":"This is a blog for testing! ä»…ä¾›æµ‹è¯•å·¦ä¸‹è§’æœ‰éŸ³ä¹å“¦ç©å¾—æ„‰å¿« JUST A DEMO! test for alertså–µå‘¼å‘¼å–µå‘¼å‘¼o(&#x3D;â€¢ã‚§â€¢&#x3D;)m æˆåŠŸæˆåŠŸå•¦o(ï¿£â–½ï¿£)ãƒ– å±é™©æœ‰å±é™©Î£(ã£ Â°Ğ” Â°;)ã£ æ¶ˆæ¯æœ‰æ¶ˆæ¯(ãƒ»âˆ€ãƒ»(ãƒ»âˆ€ãƒ»(ãƒ»âˆ€ãƒ»*) å½“å¿ƒå½“å¿ƒå“¦â‰§ ï¹ â‰¦ test for folder è¿™æ˜¯ä¸€ä¸ªå±•å¼€äº†çš„folder ä»€ä¹ˆéƒ½æ²¡æœ‰æ è¿™æ˜¯ä¸€ä¸ªå…³é—­çš„folder è®°å¾—æ‰“å¼€éŸ³ä¹å“¦ï¼ *ä½ ä¸Šå½“äº†æ* test for blurè¿™æ˜¯ä¸€å¥è¢«æ¨¡ç³Šçš„è¯­å¥ test for image insertå°è¯•ç‚¹å‡»ä¸€ä¸‹å§ğŸ‘‡ test for playing youtube æ²¡æƒ³åˆ°å§æ˜¯åŒé‡è¯ˆéª— thats allï¼"},{"title":"hello-world","date":"2023-03-20T06:04:12.000Z","url":"/2023/03/20/hello-world/","categories":[["Demo","/categories/Demo/"]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]