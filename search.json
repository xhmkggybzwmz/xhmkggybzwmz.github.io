[{"title":"3231note","date":"2023-04-25T14:32:58.000Z","url":"/2023/04/26/3231note/","tags":[["COMP3231","/tags/COMP3231/"]],"categories":[["notes","/categories/notes/"]],"content":"UNSW COMP3231 23T1 notes Lec 02 Processes and ThreadsProcesses:• Also called a task or job • Memory image of an individual program • “Owner” of resources allocated for program execution • Encompasses one or more threads Threads:• Unit of execution 执行命令的单位 • Can be traced • list the sequence of instructions that execute • Belongs to a process • Executes within it. One Process may contain one or more threads. Process TerminationConditions which terminate processes 1. Normal exit (voluntary) 2. Error exit (voluntary) 3. Fatal error (involuntary) 4. Killed by another process (involuntary) Process and Thread StatesRunning Blocked Ready Running → Ready• Voluntary Yield() • End of timeslice Running → Blocked• Waiting for input • File, network, • Waiting for a timer (alarm signal) • Waiting for a resource to become available SchedularSometime called as dispatcher, it will choose a ready process to run. BUT: It is inefficient to search through all processes e.g: Ready Queue &amp; Blocked Queue Thread Model Per process items Per thread items Address spaceGlobal variablesOpen filesChild processesPending alarmsSignals and signal handlersAccounting information Program counterRegistersStack (Each thread has its own stack)State Local variables are per thread (allocated on the stack) Global variables are shared between all threads (Allocated in the data section) Concurrency control is an issue. Dynamically allocated memory can be global or local -&gt; Program defined Thread Usage Model 模型 Characteristics 特性 Threads Parallelism. Blocking system calls Single-threaded Process No parallelism, blocking system calls Finite-state Machine Parallelism, nonblocking system calls, interrupts Summary in Threads Simpler to program than a state machine Less resources associated with threads than multiple complete processes Cheaper to create and destroy Share resources (especially memory) between them Performance: Threads waiting for IO can be overlapped with computing threads If all threads are compute bound(被运算速度限制), then there is no performance improvement (on uniprocessor) Threads can take advantage of the parallelism available on machines with more than one CPU (multiprocessor) Lec 03 Concurrency and SynchronisationConcurrency Example:Trying to modify a global variable in two threads The reason for why there is in-kernel concurrency for single-threaded processes: Multi-tasking Interrupt handling Device drivers System calls Resource sharing Critical Region and how to identifyA critical region is a region of code where shared resources are accessed. We can control access to the shared resource by controlling access to the code that accesses the resource. Uncoordinated entry to the critical region results in a race condition (Concurrency Occurs) HOW TO IDENTIFY: Critical regions are the regions of code that access a shared resource, and correctness relies on the shared resource not being concurrently modified by another thread&#x2F;process&#x2F;entity.\\ HOW TO PREVENT: Critical Regions SolutionsConditions required of any solution to the critical region problem: Mutual exclusion: No two processes&#x2F;threads in the critical region at the same time No assumptions made about speeds or numbers of CPUs No process running outside its critical region may block another process No process waited forever to enter its critical region (Bounded) Mutual exclusion by taking turnsWorks for solving concurrency issues: strict alternation -&gt; each process takes turns Cons (缺点) Busy waiting Process must wait its turn even while the other process is doing something else In a multiple processes condition, must wait for everyone to have a turn Does not guarantee progress if a process no longer needs a turn Poor solution when processes require the critical section at different rates Mutual Exclusion by disabling interruptsHow it works: Before entering a critical region, disable interrupts. After leaving the critical region, enable interrupts. Cons: Only available in the kernel Delays everybody else, even with no contention Slows the interrupt response time Does not work on a multiprocessor Hardware Support for mutual exclusionTest and Set instruction •Can be used to implement lock variables correctly •Load the value of the lock •If lock &#x3D;&#x3D; 0 •Set the lock to 1 •Return the result 0 -&gt; we acquire the lock •if lock &#x3D;&#x3D; 1 • return 1 -&gt; another thread&#x2F;process has the lock •Hardware guarantees that the instruction executes atomically -&gt; not be interrupt Pros: Simple (easy to verify work or not) Available at user level Work with any number of processors To implement any number of lock variables Cons: Busy waits (also named as a spin lock) Consumes CPU Starvation is possible when a process leaves its critical section and more than one process is waiting. Tackling the busy-wait problem:Sleep&#x2F;Wakeup When the process is waiting for an event, it calls sleep to block, instead of busy waiting. The event happens, the event generator (another process) calls wakeup to unblock the sleeping process. Waking a ready&#x2F;running process has no effect. Producer-Consumer Problem(bounded buffer problem)Description: producer produces data items and store items in a buffer. Consumer takes the items out of the buffer and consumes them. Issues:Producer Should sleep when the buffer is full. And wakeup when there is empty space in the buffer. The consumer can call wakeup when it consumes the first entry of the full buffer. Consumer Should sleep when the buffer is empty. And wakeup when there are items available. Producer can call wakeup when it adds the first item to the buffer. SemaphoresTwo primitives that are more powerful than simple sleep and wakeup alone. • P(): proberen, from Dutch to test. • V(): verhogen, from Dutch to increment. • Also called wait &amp; signal, down &amp; up. How it works: If a resource is not available, the corresponding semaphore blocks any process waiting for the resource. Blocked processes are put into a process queue maintained by the semaphore (avoids busy waiting!) When a process releases a resource, it signals this by means of the semaphore. Signaling resumes a blocked process if there is any. Wait (P) and signal (V) operations cannot be interrupted. Complex coordination can be implemented by multiple semaphores. The initial count determines how many waits can progress before blocking and requiring a signal. Producer Consumer problem with semaphores: Summarising SemaphoresSemaphores can be used to solve a variety of concurrency problems. However, programming with then can be error-prone: E.g. must signal for every wait To many or too few signals or waits, or signals and waits in the wrong order, can have bad results. MonitorA higher level synchronisation primitive. Programming language construct IDEA: A set of procedures&#x2F;variables&#x2F;data types are grouped in a special module:monitor. Variables and data types can only be accessed from within the monitor. Only one process&#x2F;thread can be in the monitor at any one time. Mutual exclusion is implemented by the complier. When a thread calls a monitor procedure that has a thread already inside, it will be in the entry queue and will sleep until the current thread exits the monitor. Condition VariableTo allow a process to wait within the monitor, we need to declare a condition variable. Condition variable can only be used with the operations wait and signal. x.wait() Means that the process invoking this operation is suspended until another process invokes. Another thread can enter the monitor while original is suspended. x.signal() this operation resumes only one suspended process. If no process is suspended, then this operation has no effect. How to achieve producer-consumer problem with monitors is in P50 lec03. Synchronisation Primitives in OS&#x2F;161Locks Semaphores Wait (P) &#x2F; signal (V) Condition Variables Note: All three variants must hold the lock passed in. Condition Variables and Bounded Buffers cv_wait() will release the lock before block the process Producer-consumer solution with condition variable Dining Philosophers哲学家就餐问题是一个经典的计算机科学同步问题，由Edsger Dijkstra在1965年提出。问题描述了五位哲学家围坐在圆桌旁的情景，他们在思考问题和吃饭之间交替。圆桌中间有一碗意面，每两位哲学家之间有一根筷子。每位哲学家需要两根筷子才能吃饭。哲学家们不能交谈，只能思考或吃饭。 问题在于设计一个协议，使得每位哲学家都能够在需要时使用两根筷子吃饭，而不会出现死锁（即所有哲学家都在等待筷子，无法继续吃饭）或者饥饿（即某位哲学家长时间无法获得筷子）的情况。 以下是一个可能的解决方案： 我们可以为每根筷子分配一个编号（例如，1到5），并为每位哲学家分配一个编号。每位哲学家在需要吃饭时，先尝试拿起编号较低的筷子，然后尝试拿起编号较高的筷子。当哲学家同时拥有两根筷子时，他们可以开始吃饭。吃完饭后，他们将筷子放回原位，然后继续思考。 这种方法可以避免死锁，因为至少有一位哲学家（具有最低编号筷子的哲学家）可以拿起两根筷子并开始吃饭。其他哲学家则需要等待筷子被放回。虽然这种方法可能导致某些哲学家等待时间较长，但可以确保所有哲学家都有机会吃饭，避免饥饿现象。 Reader and Writer Problem读者-写者问题是一个经典的计算机科学并发控制问题，用于描述多个进程在访问共享资源时需要进行同步的场景。在这个问题中，有一些读者进程和写者进程。读者进程只读取共享资源，而写者进程可以修改共享资源。问题的挑战在于设计一个同步协议，以允许多个读者进程同时访问共享资源，但在写者进程访问资源时，确保其他进程（读者和写者）无法访问资源。 以下是一个可能的解决方案： 我们可以使用互斥量（mutex）和信号量（semaphore）来实现这个协议。在这个解决方案中，我们需要一个互斥量来保护对共享资源的访问计数器，以及一个信号量来控制对共享资源的访问。 读者进程： 请求互斥量以修改访问计数器。 将访问计数器加1。如果这是第一个读者进程，请求信号量以阻止写者进程访问共享资源。 释放互斥量。 访问共享资源。 请求互斥量以修改访问计数器。 将访问计数器减1。如果这是最后一个读者进程，释放信号量以允许写者进程访问共享资源。 释放互斥量。 写者进程： 请求信号量以阻止其他进程访问共享资源。 访问共享资源。 释放信号量以允许其他进程访问共享资源。 这个解决方案允许多个读者进程同时访问共享资源，但当有写者进程需要访问资源时，它们将等待所有当前的读者进程完成。同样，在写者进程访问共享资源时，其他读者和写者进程将被阻止。这种方法可以确保在写者进程访问资源时，没有其他进程可以访问共享资源。 Lec04 DeadLockDeadLock &amp; ResourcesDeadlocks occurs when Processes are granted exclusive access to devices&#x2F;locks&#x2F;tables.. We refer to these entities generally as resources. Deadlock: definition A set of processes is deadlocked if each process in the set is waiting for an event that only another process in the set can cause. In the deadlock situation, no process can Run Release resources Be awakened Four conditions for deadlock Mutual exclusion condition Each resource assigned to 1 process or is available Hold and wait condition Process holding resources can request additional No preemption condition Previously granted resources cannot be forcibly taken away Circular wait condition Must be a circular chain of 2 or more processes Each is waiting for resource held by next member of the chain Deadlock avoidance Just ignore the problem altogether Prevention 预防 Negating on of the four necessary conditions Detection and recovery Dynamic avoidance Careful resource allocation Method 1: Ostrich AlgorithmPretend there is no problem Reasonable if Deadlocks occur very rarely Cost of prevention is high UNIX and Windows takes this approach for some of the more complex resource relationships they manage It’s a trade off between Convenience (engineering approach) Correctness (mathematical approach) Method 2: Deadlock preventionResource allocation rules prevent deadlock by prevent one of the four conditions required for deadlock from occurring: Mutual exclusion Hold and wait No preemption Circular Wait Attacking the Mutual Exclusion Condition (Not feasible)Not feasible in general Some devices&#x2F;resources are intrinsically(本质上) not sharable. Attacking the hold and wait condition (request resources initially)Require processes to request resources before starting A process never has to wait for what it needs Issues: May not know required resources at start of run Which means not always possible Also ties up resources other processes could be using Variations: Process must give up all resources if it would block holding a resource Then request all immediately need Prone(倾向于) to livelock Attacking the No Preemption condition(无优先权条件)(take resources away)Not a viable option Attacking the circular wait condition (Order resources)Numerically ordered resources (Resources ordering is a common technique) Method 3: Detection and recoveryNeed a method to determine if a system is deadlocked. Assuming deadlocked is detected, we need a method of recovery to restore progress to the system. Strategy:Note the resource ownership and requests A cycle can be found within the graph, which denotes a deadlock Detection with Multiple Resources of Each Type Sum of current resource allocation + resources available &#x3D; resources that exist Algorithm Look for an unmarked process Pi, for which the i-th row of R is less than or equal to A. If found, add the i-th row of C to A, and mark Pi, then go back to step 1. If no such process exists, terminate. The remaining processes are deadlocked. Recovery from DeadlockRecovery through preemption • take a resource from some other process • depends on nature of the resource Recovery through rollback • checkpoint a process periodically • use this saved state • restart the process if it is found deadlocked • No guarantee is won’t deadlock again Recovery through killing processes • crudest but simplest way to break a deadlock • kill one of the processes in the deadlock cycle • the other processes get its resources • choose process that can be rerun from the beginning Method 4: Deadlock AvoidanceOnly enough information is available in advance, we can avoid a deadlock. Maximum number of each resource required Safe and Unsafe statesA state is safe if • The system is not deadlocked • There exists a scheduling order that results in every process running to completion, even if they all request their maximum resources immediately Unsafe states are not necessarily deadlocked • With a lucky sequence, all processes may complete • However, we cannot guarantee that they will complete (not deadlock) • Safe states guarantee we will eventually complete all processes •Deadlock avoidance algorithm • Only grant requests that result in safe states LiveLockLivelocked processes are not blocked, change state regularly, but never make progress Bankers AlgorithmModelled on a Banker with Customers • The banker has a limited amount of money to loan customers • Limited number of resources • Each customer can borrow money up to the customer’s credit limit • Maximum number of resources required Basic Idea • Keep the bank in a safe state • So all customers are happy even if they all request to borrow up to their credit limit at the same time. • Customers wishing to borrow such that the bank would enter an unsafe state must wait until somebody else repays their loan such that the the transaction becomes safe StarvationA process never receives the resource it is waiting for, despite the resource (repeatedly) becoming free, the resource is always allocated to another waiting process One Solution: First come, first server Lec05 Processes and Threads ImplementationMIPS RegistersUser-mode accessible registers • 32 general purpose registers • r0 hardwired to zero • r31 the link register for jump-and-link (JAL) instruction HI&#x2F;LO • 2 * 32-bits for multiply and divide PC • Not directly visible • Modified implicitly by jump and branch instructions Branching and JumpingBranching and jumping have a branch delay slot • The instruction following a branch or jump is always executed prior to destination of jump ProcessMemory allocationMinimally consist of three segments • Text • contains the code (instructions) • Data • Global variables • Stack • Activation records of procedure&#x2F;function&#x2F;method • Local variables Note: • data can dynamically grow up • E.g., malloc()-ing • The stack can dynamically grow down • E.g., increasing function call depth or recursion P23 lec05 Mode distinguishUser-mode • Processes (programs) scheduled by the kernel • Isolated from each other • No concurrency issues between each other System-calls transition into and return from the kernel Kernel-mode • Nearly all activities still associated with a process • Kernel memory shared between all processes • Concurrency issues exist between processes concurrently executing in a system call User-level Threads Implementation at user-level • User-level Thread Control Block (TCB), ready queue, blocked queue, and dispatcher • Kernel has no knowledge of the threads (it only sees a single process) • If a thread blocks waiting for a resource held by another thread inside the same process, its state is saved and the dispatcher switches to another ready thread • Thread management (create, exit, yield, wait) are implemented in a runtime support library Pros• Thread management and switching at user level is much faster than doing it in kernel level • No need to trap (take syscall exception) into kernel and back to switch • Dispatcher algorithm can be tuned to the application • E.g. use priorities • Can be implemented on any OS (thread or non-thread aware) • Can easily support massive numbers of threads on a per-application basis • Use normal application virtual memory • Kernel memory more constrained. Difficult to efficiently support wildly differing numbers of threads for different applications Cons• Threads have to yield() manually (no timer interrupt delivery to user level) • Co-operative multithreading • A single poorly design&#x2F;implemented thread can monopolise the available CPU time • There are work-arounds (e.g. a timer signal per second to enable pre-emptive multithreading), they are course grain and a kludge. • Does not take advantage of multiple CPUs (in reality, we still have a single threaded process as far as the kernel is concerned) • If a thread makes a blocking system call (or takes a page fault), the process (and all the internal threads) blocks • Can’t overlap I&#x2F;O with computation Kernel-provided Threads Threads are implemented by the kernel • TCBs (thread control block) are stored in the kernel • A subset of information in a traditional PCB (process control block) • The subset related to execution context • TCBs have a PCB associated with them • Resources associated with the group of threads (the process) • Thread management calls are implemented as system calls • E.g. create, wait, exit Cons• Thread creation and destruction, and blocking and unblocking threads requires kernel entry and exit. • More expensive than user-level equivalent Pros• Preemptive multithreading • Parallelism • Can overlap blocking I&#x2F;O with computation • Can take advantage of a multiprocessor Context SwitchContext Switch is what the lowest level of OS does when an interrupt occurs. A context switch can refer to • A switch between threads • Involving saving and restoring of state associated with a thread • A switch between processes • Involving the above, plus extra state associated with a process. • E.g. memory maps Context Switch OccurrenceA switch between process&#x2F;threads can happen any time the OS is invoked • On a system call • Mandatory if system call blocks or on exit(); • On an exception • Mandatory if offender is killed • On an interrupt • Triggering a dispatch is the main purpose of the timer interrupt A thread switch can happen between any two instructions Note instructions do not equal program statements Context Switch Addition Context switch must be transparent for processes&#x2F;threads • When dispatched again, process&#x2F;thread should not notice that something else was running in the meantime (except for elapsed time) OS must save all state that affects the thread • This state is called the process&#x2F;thread context • Switching between process&#x2F;threads consequently results in a context switch. Lec06 SyscallsSyscall DefinitionCan be viewed as special function calls • Provides for a controlled entry into the kernel • While in kernel, they perform a privileged operation • Returns to original caller with the result The system call interface represents the abstract machine provided by the operating system. CPU Computation ModelThe fetch-execute cycle • Load memory contents from address in program counter (PC) • The instruction • Execute the instruction • Increment PC • Repeat Privileged-mode operationTo protect operating system execution, two or more CPU modes of operation exist • Privileged mode (system-, kernel-mode) • All instructions and registers are available • User-mode • Uses ‘safe’ subset of the instruction set • Only affects the state of the application itself • They cannot be used to uncontrollably interfere with OS • Only ‘safe’ registers are accessible The accessibility of addresses within an address space changes depending on operating mode • To protect kernel code and data • Note: The exact memory ranges are usually configurable, and vary between CPU architectures and&#x2F;or operating systems. System call mechanism securely transfers from user execution to kernel execution and back. System call mechanism overview• Processor mode • Switched from user-mode to kernel-mode • Switched back when returning to user mode • Stack Pointer (SP) • User-level SP is saved and a kernel SP is initialised • User-level SP restored when returning to user-mode • Program Counter (PC) • User-level PC is saved and PC set to kernel entry point • User-level PC restored when returning to user-level • Kernel entry via the designated entry point must be strictly enforced •Registers • Set at user-level to indicate system call type and its arguments • A convention between applications and the kernel • Some registers are preserved at user-level or kernel-level in order to restart user-level execution • Depends on language calling convention etc. • Result of system call placed in registers when returning to user-level • Another convention We need system calls because function calls do not: Change from user to kernel mode&#x2F;back again Restrict possible entry points to secure locations Coprocessor 0 (CP0)The processor control registers are located in CP0 Exception&#x2F;Interrupt management registers Translation management registers Exception management C0_statusWe only focus on 0-15 bits ·c0_causeThe 2nd-6th bit is for ExcCode -&gt; The code number of the exception taken C0_epcThe Exception Program Counter • Points to address of where to restart execution after handling the exception or interrupt Hardware Exception handlingBasic situation: Assume an interrupt occurred as the previous instruction completed &amp; We are in user mode with interrupts enabled. Steps: Instruction address at which to restart after the interrupt is transferred to EPC Interrupts disabled and previous state shifted along What stored in IEc&#x2F;KUc is now in IEp&#x2F;KUp Kernel mode is set, and previous state shifted along What stored in IEp&#x2F;KUp (before 2 a) executed) is now in IEo&#x2F;KUo Code for the exception placed in Cause -&gt; ExcCode in c0_cause is now 0 (0 is the code for interrupt) Address of general exception vector placed in PC CPU now running in kernel mode at the address in PC, with interrupt disabled All information required to Find out what caused the exception Restart after exception handling Is in coprocessor registers (Ignore how the OS handles the exception) Load the contents of EPC Store the EPC back in the PC In the branch delay slot (happens when we jump back to the PC&#x2F;user mode), execute a restore from exception instruction -&gt; move back KU&#x2F;IE Now back in the same state we were when the exception happened MIPS System Calls• System calls are invoked via a syscall instruction. • The syscall instruction causes an exception and transfers control to the general exception handler • A convention (an agreement between the kernel and applications) is required as to how user-level software indicates • Which system call is required • Where its arguments are • Where the result should go OS&#x2F;161 Systems CallsOS&#x2F;161 uses the following conventions: • Arguments are passed and returned via the normal C function calling convention • Additionally • Reg v0 contains the system call number • On return, reg a3 contains • 0: if success, v0 contains successful result • not 0: if failure, v0 has the errno. • v0 stored in errno • -1 returned in v0 Summary of System Call in User Mode• From the caller’s perspective, the read() system call behaves like a normal function call • It preserves the calling convention of the language •However, the actual function implements its own convention by agreement with the kernel • Our OS&#x2F;161 example assumes the kernel preserves appropriate registers(s0-s8, sp, gp, ra). •Most languages have similar libraries that interface with the operating system. System Calls – Kernel Side• Things left to do • Change to kernel stack • Preserve registers by saving to memory (on the kernel stack) • Leave saved registers somewhere accessible to • Read arguments • Store return values • Do the “read()” • Restore registers • Switch back to user stack • Return to application Lec07 Computer Hardware ReviewMemory Hierarchy Cashing•Given two-levels of data storage: small and fast, versus large and slow, • Can speed access to slower storage by using intermediate-speed storage as a cache. CPU cache • CPU cache is fast memory placed between the CPU and main memory • 1 to a few cycles access time compared to RAM access time of tens – hundreds of cycles • Holds recently used data or instructions to save memory accesses. • Matches slow RAM access time to CPU speed if high hit rate • Is hardware maintained and (mostly) transparent to software • Sizes range from few kB to tens of MB. • Usually a hierarchy of caches (2–5 levels), on- and off-chip PerformanceThe performance depends on the hit rate in the first level. Effective Access Time Avoid Waiting for Disk Access• Keep a subset of the disk’s data in main memory OS uses main memory as a cache of disk contents Avoid Waiting for Internet Access• Keep a subset of the Internet’s data on disk Application uses disk as a cache of the internet Lec08 File ManagementFile NamesFile system must provide a convenient naming scheme • Textual Names • May have restrictions • Only certain characters • E.g. no ‘&#x2F;’ characters • Limited length • Only certain format • E.g DOS, 8 + 3 • Case (in)sensitive • Names may obey conventions (.c files for C files) • Interpreted by tools (e.g. UNIX) • Interpreted by operating system (e.g. Windows “con:”) File Structure• Sequence of Bytes • OS considers a file to be unstructured • Applications can impose their own structure • Used by UNIX, Windows, most modern OSes P9 lec08 File Types• Regular files •Directories •Device Files –May be divided into •Character Devices – stream of bytes •Block Devices •Some systems distinguish between regular file types –ASCII text files, binary files File Access Types (Patterns)•Sequential access 顺序读写 –read all bytes&#x2F;records from the beginning –cannot jump around, could rewind or back up –convenient when medium was magnetic tape •Random access 随机读写 –bytes&#x2F;records read in any order –essential for data base systems –read can be … •move file pointer (seek), then read or –lseek(location,…);read(…) •each read specifies the file pointer –read(location,…) Typical File Operations Create Delete Open Close Read Write Append Seek Get attributes Set Attribute Rename Criteria for File OrganizationThings to consider when designing file layout •Rapid access –Needed when accessing a single record –Not needed for batch mode •read from start to finish •Ease of update –File on CD-ROM will not be updated, so this is not a concern •Economy of storage –Should be minimum redundancy in the data –Redundancy can be used to speed access such as an index File Directories•Provide mapping between file names and the files themselves •Contain information about files –Attributes –Location –Ownership •Directory itself is a file owned by the operating system Hierarchical (Tree Structured) Directory•Files can be located by following a path from the root, or master, directory down various branches –This is the absolute pathname for the file •Can have several files with the same file name as long as they have unique path names(同一路径下的文件名不得相等) Relative and Absolute Pathnames•Absolute pathname –A path specified from the root of the file system to the file A Relative pathname –A pathname specified from the cwd (current working directory) Typical Directory Operations Create Delete Opendir Closedir Readdir Rename Link Unlink Nice Properties of UNIX naming•Simple, regular format –Names referring to different servers, objects, etc., have the same syntax. •Regular tools can be used where specialised tools would be otherwise be needed. •Location independent –Objects can be distributed or migrated, and continue with the same names Access RightsIn multiuser system, we need to consider the issue of the access rights. Different kinds of Access Rights: None User may not know the existence of the file User is not allowed to read the directory that includes the file Knowledge User can only determine that the file exists and who its owner is Execution The user can load and execute a program but cannot copy it Reading The user can read the file for any purpose, including copying and execution Appending The user can add data to the file but cannot modify or delete any of the file’s contents Updating The user can modify, delete, and add to the file’s data. This includes creating the file, rewriting it, and removing all or part of the data Changing protection User can change access rights granted to other users Deletion User can delete the file Owners Has all rights previously listed May grant rights to others using the following classes of users •Specific user •User groups •All for public files Simultaneous AccessIn multiuser system, we need to consider the issue of the simultaneous access. •Most OSes provide mechanisms for users to manage concurrent access to files –Example: flock(), lockf(), system calls •Typically –User may lock entire file when it is to be updated –User may lock the individual records (i.e. ranges) during the update •Mutual exclusion and deadlock are issues for shared access Lec09 File System InternalsUNIX Storage StackFrom lower to Higher: Hard disk platters: Tracks Sectors Disk controller Hides disk geometry, bad sectors Exposes linear sequence of blocks(disk’s interface) Device driver Hides device-specific protocol Exposes block-device interface Disk scheduler&#x2F;buffer cache -&gt; Optimisations Keep recently accessed disk blocks in memory Schedule disk accesses from multiple processes for performance and fairness File System Hides physical location of data on the disk Exposes: Directory hierarchy 目录的层次结构 Symbolic file names Random-access files Protrction Virtual File System (VFS) Unified interface to multiple File systems Open File Table (OF table)&#x2F;File Descriptor Table (FD table) Keep track of files opened by user-level processes Matches syscall interface to VFS interface Difference between some FSDifferent physical nature of storage devices – Ext3 is optimised for magnetic disks – JFFS2 is optimised for flash memory devices – ISO9660 is optimised for CDROM Different storage capacities – FAT16 does not support drives &gt;2GB – FAT32 becomes inefficient on drives &gt;32GB – ZFS, Btrfs is designed to scale to multi-TB disk arrays Different CPU and memory requirements – FAT16 is not suitable for modern PCs but is a good fit for many embedded devices Proprietary standards – NTFS may be a nice FS, but its specification is closed Property of hard disk– Seek time • ~15ms worst case – Rotational delay • 8ms worst case for 7200rpm drive – For comparison, disk-to-buffer transfer speed of a modern drive is ~10µs per 4K block Conclusion: keep blocks that are likely to be accessed together close to each other Implementing a file systemRequirementsThe FS must map symbolic file names into a collection of block addresses. The FS must keep track of – which blocks belong to which files. – in what order the blocks form the file – which blocks are free for allocation Given a logical region of a file, the FS must track the corresponding block(s) on disk. File Allocation MethodsContiguous Allocation✔ Easy bookkeeping (need to keep track of the starting block and length of the file) ✔ Increases performance for sequential operations ✗ Need the maximum size for the file at the time of creation ✗ As files are deleted, free space becomes divided into many small chunks (external fragmentation) Example: ISO 9660 (CDROM) Dynamic Allocation Strategies– Disk space allocated in portions as needed – Allocation occurs in fixed-size blocks ✔ No external fragmentation ✔ Does not require pre-allocating disk space ✗ Partially filled blocks (internal fragmentation) ✗ File blocks are scattered across the disk ✗ Complex metadata management (maintain the collection of blocks for each file) Examples come after: Linked list allocation File Allocation Table (FAT) Inode-based FS structure External and Internal fragmentationExternal fragmentation– The space wasted external to the allocated memory regions – Memory space exists to satisfy a request but it is unusable as it is not contiguous Internal fragmentation– The space wasted internal to the allocated memory regions – Allocated memory may be slightly larger than requested memory; this size difference is wasted memory internal to a partition ConclusionInternal fragmentation is inside the allocated memory blocks External fragmentation is between two allocated memory blocks Dynamic allocation : Linked list allocationEach block contains the block number of the next block in the chain. Free blocks are also linked in a chain. ✔ Only single metadata entry per file ✔ Best for sequentially accessed files ✗ Poor for random access ✗ Blocks end up scattered across the disk due to free list eventually being randomised Dynamic Allocation: File allocation Table (FAT)• Keep a map of the entire FS in a separate table – A table entry contains the number of the next block of the file – The last block in a file and empty blocks are marked using reserved values • The table is stored on the disk and is replicated in memory • Random access is fast (following the in-memory list) Issues: Requires a lot of memory for large disks File allocation table disk layout Dynamical Allocation: inode-based FS structureIdea: separate table (index-node or i-node) for each file. – Only keep table for open files in memory – Fast random access The most popular FS structure today Issues: i-nodes occupy one or several disk areas i-nodes are allocated dynamically, hence free-space management is required for i-nodes – Use fixed-size i-nodes to simplify dynamic allocation – Reserve the last i-node entry for a pointer (a block number) to an extension i-node Free-space management Approach 1: Linked list of free blocks in free blocks on disk Keep bitmaps of free blocks and free i-nodes on disk Free block ListList of all unallocated blocks Background jobs can re-order list for better contiguity Store in free blocks themselves – Does not reduce disk capacity Only one block of pointers need be kept in the main memory Bit tablesIndividual bits in a bit vector flags used&#x2F;free blocks 16GB disk with 512-byte blocks –&gt; 4MB table May be too large to hold in main memory Expensive to search – Optimisations possible, e.g. a two level table Concentrating (de)allocations in a portion of the bitmap has desirable effect of concentrating access Simple to find contiguous free space Implementing directories• Directories are stored like normal files – directory entries are contained inside data blocks • The FS assigns special meaning to the content of these files – a directory file is a list of directory entries – a directory entry contains file name, attributes, and the file i-node number • maps human-oriented file name to a system-oriented name Fixed-size directory entries– Either too small • Example: DOS 8+3 characters – Or waste too much space • Example: 255 characters per file name Variable-size directory entries– Freeing variable length entries can create external fragmentation in directory blocks • Can compact when block is in RAM Searching Directory methods Linear scan Implement a directory cache in software to speed-up search Hash lookup B-tree Storing file attributes Disk addresses and attributes in directory entry -&gt; FAT Directory in which each entry just refers to an i-node -&gt; UNIX File system block sizeFile systems deal with 2 types of blocks – Disk blocks or sectors (usually 512 bytes) – File system blocks 512 * 2^N bytes What should N be will be the problem. • Smaller blocks waste less disk space (less internal fragmentation) • Sequential Access – The larger the block size, the fewer I&#x2F;O operations required • Random Access – The larger the block size, the more unrelated data loaded. – Spatial locality of access improves the situation • Choosing an appropriate block size is a compromise Lec10 UNIX File Management (continue)Virtual file system (VFS)Traversing the directory hierarchy may require VFS to issue requests to several underlying file systems. • Provides single system call interface for many file systems – E.g., UFS, Ext2, XFS, DOS, ISO9660,… • Transparent handling of network file systems – E.g., NFS, AFS, CODA • File-based interface to arbitrary device drivers (&#x2F;dev) • File-based interface to kernel data structures (&#x2F;proc) • Provides an indirection layer for system calls – File operation table set up at file open time – Points to actual handling code for particular type – Further file operations redirected to those functions Data Types in VFS InterfaceVFS Represent all file system types Contains pointers to functions to manipulate each file system as a whole Form a standard interface to the file system Vnode Represents a file (inode) in the underlying filesystem Points to the real inode Contains pointers to funcions to manipulate files&#x2F;inodes like open&#x2F;close&#x2F;read File descriptorsAttributes Each open file has a file descriptor Read&#x2F;Write&#x2F;Lseek&#x2F;… use them to specify which file to operate on. State associated with a file descriptor File pointer Determine where in the file the next read or write is performed Mode Was the file opened with read-only permission or sth… Use single fd table with no of tableHow to achieve: Use vnode numbers as file descriptors and add a file pointer to the vnode. Problem: Cannot handling concurrency situations. At this situation: we only have a single global open file array. Entries contains file pointer and a pointer to a vnode. Issues: File descriptor 1 is stdout -&gt; console for some processes but may be a file for other processes Entry 1 should be different different per process! Per-process File descriptor array Each process has its own open file array Issue Fork Fork defines that the child shares the file pointer with the parent Dup2 Also defines the file descriptors share the file pointer With per-process table, we can only have independent file pointers, even when accessing the same file Per-Process fd table with global open file table Per-process file descriptor array contains pointers to open file table entry Open file table array contains entries with a file pointer and a pointer to an vnode. This model provides Shared file pointers if required Independent file pointers if required This model used by linux and most other UNIX operating systems Buffer–Temporary storage used when transferring data between two entities •Especially when the entities work at different rates •Or when the unit of transfer is incompatible •Example: between application program and disk Buffer disk blocks•Allow applications to work with arbitrarily sized region of a file –However, apps can still optimise for a particular block size •Writes can return immediately after copying to kernel buffer –Avoids waiting until write to disk is complete –Write is scheduled in the background •Can implement read-ahead by pre-loading next block on disk into kernel buffer –Avoids having to wait until next read is issued CacheFast storage used to temporarily hold data to speed up repeated access to the data -&gt; such as main memory can cache disk blocks •On access –Before loading block from disk, check if it is in cache first •Avoids disk accesses •Can optimise for repeated access for single or several processes Buffer and caching are related•Data is read into buffer; an extra independent cache copy would be wasteful •After use, block should be cached •Future access may hit cached copy •Cache utilises unused kernel memory space; –may have to shrink, depending on memory demand Cache replacementWhen the buffer cache is full and we need to read another block into memory, we must choose an existing entry to replace Policies: FIFO (first in first out) Least recently used Etc. File system consistencyGenerally, cached disk blocks are prioritised in terms of how critical they are to file system consistency. –Directory blocks, inode blocks if lost can corrupt entire filesystem •These blocks are usually scheduled for immediate write to disk –Data blocks if lost corrupt only the file that they are associated with •These blocks are only scheduled for write back to disk periodically •In UNIX, flushd (flush daemon) flushes all modified blocks to disk every 30 seconds Possible SolutionWrite-through cache All modified blocks are written immediately to disk But this will generate more disk traffic Works in the following situations: Floppies were removed from drives Users were constantly resetting (or crashing) their machines This method is still be used in USB storage. NOT FINISHED YET"},{"title":"test for categories","date":"2023-03-21T08:13:40.000Z","url":"/2023/03/21/test-for-cat/","tags":[["test","/tags/test/"]],"categories":[["Demo","/categories/Demo/"]],"content":"This is a blog for testing! 仅供测试左下角有音乐哦玩得愉快 JUST A DEMO! test for alerts喵呼呼喵呼呼o(&#x3D;•ェ•&#x3D;)m 成功成功啦o(￣▽￣)ブ 危险有危险Σ(っ °Д °;)っ 消息有消息(・∀・(・∀・(・∀・*) 当心当心哦≧ ﹏ ≦ test for folder 这是一个展开了的folder 什么都没有捏 这是一个关闭的folder 记得打开音乐哦！ *你上当了捏* test for blur这是一句被模糊的语句 test for image insert尝试点击一下吧👇 test for playing youtube 没想到吧是双重诈骗 thats all！"},{"title":"hello-world","date":"2023-03-20T06:04:12.000Z","url":"/2023/03/20/hello-world/","categories":[["Demo","/categories/Demo/"]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]